<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/notifa/ai/util/UsageStatsHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/notifa/ai/util/UsageStatsHelper.kt" />
              <option name="originalContent" value="package com.notifa.ai.util&#10;&#10;import android.app.usage.UsageStatsManager&#10;import android.content.Context&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import java.time.LocalDate&#10;import java.time.ZoneId&#10;import java.util.Calendar&#10;import java.util.TimeZone&#10;&#10;data class AppUsageData(&#10;    val appName: String,&#10;    val packageName: String,&#10;    val notificationCount: Int,&#10;    val usageTimeMillis: Long&#10;)&#10;&#10;object UsageStatsHelper {&#10;&#10;    private const val MILLIS_PER_DAY = 24L * 60 * 60 * 1000&#10;&#10;    private fun dayStartMillis(): Long {&#10;        return if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            try {&#10;                val zone = ZoneId.systemDefault()&#10;                LocalDate.now(zone).atStartOfDay(zone).toInstant().toEpochMilli()&#10;            } catch (_: Throwable) {&#10;                legacyDayStart()&#10;            }&#10;        } else legacyDayStart()&#10;    }&#10;&#10;    private fun legacyDayStart(): Long {&#10;        val now = System.currentTimeMillis()&#10;        val tz = TimeZone.getDefault()&#10;        val offset = tz.getOffset(now)&#10;        return now - ((now + offset) % MILLIS_PER_DAY)&#10;    }&#10;&#10;    fun hasUsageStatsPermission(context: Context): Boolean {&#10;        val usageStatsManager = context.getSystemService(Context.USAGE_STATS_SERVICE) as UsageStatsManager&#10;        val calendar = Calendar.getInstance()&#10;        calendar.add(Calendar.DAY_OF_YEAR, -1)&#10;        val stats = usageStatsManager.queryUsageStats(&#10;            UsageStatsManager.INTERVAL_DAILY,&#10;            calendar.timeInMillis,&#10;            System.currentTimeMillis()&#10;        )&#10;        return stats != null &amp;&amp; stats.isNotEmpty()&#10;    }&#10;&#10;    fun getTopApps(context: Context, notificationCounts: Map&lt;String, Int&gt;): List&lt;AppUsageData&gt; {&#10;        val usageStatsManager = context.getSystemService(Context.USAGE_STATS_SERVICE) as UsageStatsManager&#10;        val packageManager = context.packageManager&#10;        val start = dayStartMillis()&#10;        val end = System.currentTimeMillis()&#10;        val stats = usageStatsManager.queryUsageStats(UsageStatsManager.INTERVAL_DAILY, start, end) ?: emptyList()&#10;        val appDataList = mutableListOf&lt;AppUsageData&gt;()&#10;        val seen = HashSet&lt;String&gt;()&#10;        stats.forEach { usageStats -&gt;&#10;            val packageName = usageStats.packageName&#10;            if (packageName == &quot;android&quot; || packageName.contains(&quot;systemui&quot;) || usageStats.totalTimeInForeground &lt;= 0) return@forEach&#10;            if (!seen.add(packageName)) return@forEach&#10;            val notifCount = notificationCounts[packageName] ?: 0&#10;            if (notifCount &lt;= 0) return@forEach&#10;            try {&#10;                val appInfo = packageManager.getApplicationInfo(packageName, 0)&#10;                val appName = packageManager.getApplicationLabel(appInfo).toString()&#10;                appDataList.add(&#10;                    AppUsageData(&#10;                        appName = appName,&#10;                        packageName = packageName,&#10;                        notificationCount = notifCount,&#10;                        usageTimeMillis = usageStats.totalTimeInForeground&#10;                    )&#10;                )&#10;            } catch (_: PackageManager.NameNotFoundException) { }&#10;        }&#10;        return appDataList.sortedByDescending { it.notificationCount }.take(5)&#10;    }&#10;&#10;    fun getTotalScreenTime(context: Context): Long {&#10;        val usageStatsManager = context.getSystemService(Context.USAGE_STATS_SERVICE) as UsageStatsManager&#10;        val start = dayStartMillis()&#10;        val end = System.currentTimeMillis()&#10;        val stats = usageStatsManager.queryUsageStats(UsageStatsManager.INTERVAL_DAILY, start, end) ?: emptyList()&#10;        return stats.filter { it.packageName != &quot;android&quot; &amp;&amp; !it.packageName.contains(&quot;systemui&quot;) }&#10;            .sumOf { it.totalTimeInForeground.coerceAtLeast(0) }&#10;    }&#10;&#10;    fun formatMillisToTime(millis: Long): String {&#10;        val hours = millis / (1000 * 60 * 60)&#10;        val minutes = (millis / (1000 * 60)) % 60&#10;        return if (hours &gt; 0) &quot;${hours}h ${minutes}m&quot; else &quot;${minutes}m&quot;&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.notifa.ai.util&#10;&#10;import android.app.usage.UsageStatsManager&#10;import android.content.Context&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import java.time.LocalDate&#10;import java.time.ZoneId&#10;import java.util.Calendar&#10;import java.util.TimeZone&#10;&#10;data class AppUsageData(&#10;    val appName: String,&#10;    val packageName: String,&#10;    val notificationCount: Int,&#10;    val usageTimeMillis: Long&#10;)&#10;&#10;object UsageStatsHelper {&#10;&#10;    private const val MILLIS_PER_DAY = 24L * 60 * 60 * 1000&#10;&#10;    private fun dayStartMillis(): Long {&#10;        return if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            try {&#10;                val zone = ZoneId.systemDefault()&#10;                LocalDate.now(zone).atStartOfDay(zone).toInstant().toEpochMilli()&#10;            } catch (_: Throwable) {&#10;                legacyDayStart()&#10;            }&#10;        } else legacyDayStart()&#10;    }&#10;&#10;    private fun legacyDayStart(): Long {&#10;        val now = System.currentTimeMillis()&#10;        val tz = TimeZone.getDefault()&#10;        val offset = tz.getOffset(now)&#10;        return now - ((now + offset) % MILLIS_PER_DAY)&#10;    }&#10;&#10;    fun hasUsageStatsPermission(context: Context): Boolean {&#10;        val usageStatsManager = context.getSystemService(Context.USAGE_STATS_SERVICE) as UsageStatsManager&#10;        val calendar = Calendar.getInstance()&#10;        calendar.add(Calendar.DAY_OF_YEAR, -1)&#10;        val stats = usageStatsManager.queryUsageStats(&#10;            UsageStatsManager.INTERVAL_DAILY,&#10;            calendar.timeInMillis,&#10;            System.currentTimeMillis()&#10;        )&#10;        return stats != null &amp;&amp; stats.isNotEmpty()&#10;    }&#10;&#10;    fun getTopApps(context: Context, notificationCounts: Map&lt;String, Int&gt;): List&lt;AppUsageData&gt; {&#10;        val usageStatsManager = context.getSystemService(Context.USAGE_STATS_SERVICE) as UsageStatsManager&#10;        val packageManager = context.packageManager&#10;        val start = dayStartMillis()&#10;        val end = System.currentTimeMillis()&#10;        val stats = usageStatsManager.queryUsageStats(UsageStatsManager.INTERVAL_DAILY, start, end) ?: emptyList()&#10;        val appDataList = mutableListOf&lt;AppUsageData&gt;()&#10;        val seen = HashSet&lt;String&gt;()&#10;        stats.forEach { usageStats -&gt;&#10;            val packageName = usageStats.packageName&#10;            if (packageName == &quot;android&quot; || packageName.contains(&quot;systemui&quot;) || usageStats.totalTimeInForeground &lt;= 0) return@forEach&#10;            if (!seen.add(packageName)) return@forEach&#10;            val notifCount = notificationCounts[packageName] ?: 0&#10;            if (notifCount &lt;= 0) return@forEach&#10;            try {&#10;                val appInfo = packageManager.getApplicationInfo(packageName, 0)&#10;                val appName = packageManager.getApplicationLabel(appInfo).toString()&#10;                appDataList.add(&#10;                    AppUsageData(&#10;                        appName = appName,&#10;                        packageName = packageName,&#10;                        notificationCount = notifCount,&#10;                        usageTimeMillis = usageStats.totalTimeInForeground&#10;                    )&#10;                )&#10;            } catch (_: PackageManager.NameNotFoundException) { }&#10;        }&#10;        return appDataList.sortedByDescending { it.notificationCount }.take(5)&#10;    }&#10;&#10;    fun getTotalScreenTime(context: Context): Long {&#10;        val usageStatsManager =&#10;            context.getSystemService(Context.USAGE_STATS_SERVICE) as UsageStatsManager&#10;        val start = dayStartMillis()&#10;        val end = System.currentTimeMillis()&#10;        val events = usageStatsManager.queryEvents(start, end)&#10;        var totalScreenTime = 0L&#10;        val eventLog = mutableListOf&lt;UsageEvents.Event&gt;()&#10;        while (events.hasNextEvent()) {&#10;            val event = UsageEvents.Event()&#10;            events.getNextEvent(event)&#10;            if (event.eventType == UsageEvents.Event.MOVE_TO_FOREGROUND || event.eventType == UsageEvents.Event.MOVE_TO_BACKGROUND) {&#10;                eventLog.add(event)&#10;            }&#10;        }&#10;&#10;        for (i in 0 until eventLog.size - 1) {&#10;            val currentEvent = eventLog[i]&#10;            val nextEvent = eventLog[i + 1]&#10;            if (currentEvent.eventType == UsageEvents.Event.MOVE_TO_FOREGROUND &amp;&amp;&#10;                (nextEvent.eventType == UsageEvents.Event.MOVE_TO_BACKGROUND || nextEvent.eventType == UsageEvents.Event.MOVE_TO_FOREGROUND)&#10;            ) {&#10;                val timeDiff = nextEvent.timeStamp - currentEvent.timeStamp&#10;                totalScreenTime += timeDiff&#10;            }&#10;        }&#10;        return totalScreenTime&#10;    }&#10;&#10;    fun formatMillisToTime(millis: Long): String {&#10;        val hours = millis / (1000 * 60 * 60)&#10;        val minutes = (millis / (1000 * 60)) % 60&#10;        return if (hours &gt; 0) &quot;${hours}h ${minutes}m&quot; else &quot;${minutes}m&quot;&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>